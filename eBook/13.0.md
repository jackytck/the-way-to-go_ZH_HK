# 13 錯誤處理與測試

Go 沒有像 Java 和 .NET 那樣的 `try/catch` 異常機制：不能執行拋異常操作。但是有一套 `defer-panic-and-recover` 機制（參見 13.2-13.3 節）。

Go 的設計者覺得 `try/catch` 機制的使用太氾濫了，而且從底層向更高的層級拋異常太耗費資源。他們給 Go 設計的機制也可以 “捕捉” 異常，但是更輕量，並且只應該作為（處理錯誤的）最後的手段。

Go 是怎麼處理普通錯誤的呢？通過在函式和方法中返回錯誤物件作為它們的唯一或最後一個返回值——如果返回 nil，則沒有錯誤發生——並且主調（calling）函式總是應該檢查收到的錯誤。

**永遠不要忽略錯誤，否則可能會導致程式崩潰！！**

處理錯誤並且在函式發生錯誤的地方給使用者返回錯誤資訊：照這樣處理就算真的出了問題，你的程式也能繼續執行並且通知給使用者。`panic and recover` 是用來處理真正的異常（無法預測的錯誤）而不是普通的錯誤。

庫函式通常必須返回某種錯誤提示給主調（calling）函式。

在前面的章節中我們瞭解了 Go 檢查和報告錯誤條件的慣有方式：

- 產生錯誤的函式會返回兩個變數，一個值和一個錯誤碼；如果後者是 nil 就是成功，非 nil 就是發生了錯誤。

- 為了防止發生錯誤時正在執行的函式（如果有必要的話甚至會是整個程式）被中止，在呼叫函式後必須檢查錯誤。

下面這段來自 pack1 包的程式碼 Func1 測試了它的返回值：

```go
if value, err := pack1.Func1(param1); err != nil {
	fmt.Printf("Error %s in pack1.Func1 with parameter %v", err.Error(), param1)
	return    // or: return err
} else {
	// Process(value)
}
```

*為了更清晰的程式碼，應該總是使用包含錯誤值變數的 if 複合語句*

上例除了 `fmt.Printf` 還可以使用 log 中對應的方法（參見 13.3 節 和 15.2 節），如果程式中止也沒關係的話甚至可以使用 `panic`（參見後面的章節）。

## 連結

- [目錄](directory.md)
- 上一節：[Go 中的密碼學](12.12.md)
- 下一節：[錯誤處理](13.1.md)