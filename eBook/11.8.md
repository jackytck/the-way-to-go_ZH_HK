# 11.8 第二個例子：讀和寫

讀和寫是軟體中很普遍的行為，提起它們會立即想到讀寫檔案、快取（比如位元組或字串切片）、標準輸入輸出、標準錯誤以及網路連線、管道等等，或者讀寫我們的自定義型別。為了讓程式碼儘可能通用，Go 採取了一致的方式來讀寫資料。

`io` 包提供了用於讀和寫的介面 `io.Reader` 和 `io.Writer`：

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

只要型別實現了讀寫介面，提供 `Read()` 和 `Write` 方法，就可以從它讀取資料，或向它寫入資料。一個物件要是可讀的，它必須實現 `io.Reader` 介面，這個介面只有一個簽名是 `Read(p []byte) (n int, err error)` 的方法，它從呼叫它的物件上讀取資料，並把讀到的資料放入引數中的位元組切片中，然後返回讀取的位元組數和一個 `error` 物件，如果沒有錯誤發生返回 `nil`，如果已經到達輸入的尾端，會返回 `io.EOF("EOF")`，如果讀取的過程中發生了錯誤，就會返回具體的錯誤資訊。類似地，一個物件要是可寫的，它必須實現 `io.Writer` 介面，這個介面也只有一個簽名是 `Write(p []byte) (n int, err error)` 的方法，它將指定位元組切片中的資料寫入呼叫它的物件裏，然後返回實際寫入的位元組數和一個 `error` 物件（如果沒有錯誤發生就是 `nil`）。

`io` 包裏的 `Readers` 和 `Writers` 都是不帶緩衝的，`bufio` 包裏提供了對應的帶緩衝的操作，在讀寫 `UTF-8` 編碼的文字檔案時它們尤其有用。在 第12章 我們會看到很多在實戰中使用它們的例子。

在實際程式設計中儘可能的使用這些介面，會使程式變得更通用，可以在任何實現了這些介面的型別上使用讀寫方法。

例如一個 `JPEG` 圖形解碼器，通過一個 `Reader` 引數，它可以解碼來自磁碟、網路連線或以 `gzip` 壓縮的 `HTTP` 流中的 `JPEG` 圖形資料，或者其他任何實現了 `Reader` 介面的物件。 

## 連結

- [目錄](directory.md)
- 上一節：[第一個例子：使用Sorter介面排序](11.7.md)
- 下一節：[空介面](11.9.md)