# 16.9 閉包和協程的使用

請看下面程式碼：

```go
package main

import (
    "fmt"
    "time"
)

var values = [5]int{10, 11, 12, 13, 14}

func main() {
    // 版本A:
    for ix := range values { // ix是索引值
        func() {
            fmt.Print(ix, " ")
        }() // 呼叫閉包列印每個索引值
    }
    fmt.Println()
    // 版本B: 和A版本類似，但是通過呼叫閉包作為一個協程
    for ix := range values {
        go func() {
            fmt.Print(ix, " ")
        }()
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本C: 正確的處理方式
    for ix := range values {
        go func(ix interface{}) {
            fmt.Print(ix, " ")
        }(ix)
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本D: 輸出值:
    for ix := range values {
        val := values[ix]
        go func() {
            fmt.Print(val, " ")
        }()
    }
    time.Sleep(1e9)
}

```

輸出：

```
0 1 2 3 4

4 4 4 4 4

1 0 3 4 2

10 11 12 13 14
```

版本A呼叫閉包5次列印每個索引值，版本B也做相同的事，但是通過協程呼叫每個閉包。按理説這將執行得更快，因為閉包是併發執行的。如果我們阻塞足夠多的時間，讓所有協程執行完畢，版本B的輸出是：`4 4 4 4 4`。為什麼會這樣？在版本B的迴圈中，`ix`變數實際是一個單變數，表示每個陣列元素的索引值。因為這些閉包都只繫結到一個變數，這是一個比較好的方式，當你執行這段程式碼時，你將看見每次迴圈都列印最後一個索引值`4`，而不是每個元素的索引值。因為協程可能在迴圈結束後還沒有開始執行，而此時`ix`值是`4`。

版本C的迴圈寫法才是正確的：呼叫每個閉包時將`ix`作為引數傳遞給閉包。`ix`在每次迴圈時都被重新賦值，並將每個協程的`ix`放置在棧中，所以當協程最終被執行時，每個索引值對協程都是可用的。注意這裏的輸出可能是`0 2 1 3 4`或者`0 3 1 2 4`或者其他類似的序列，這主要取決於每個協程何時開始被執行。

在版本D中，我們輸出這個陣列的值，為什麼版本B不能而版本D可以呢？

因為版本D中的變數宣告是在迴圈體內部，所以在每次迴圈時，這些變數相互之間是不共享的，所以這些變數可以單獨的被每個閉包使用。

## 連結

- [目錄](directory.md)
- 上一節：[誤用協程和通道](16.8.md)
- 下一節：[糟糕的錯誤處理](16.10.md)